---
title:  "调度器"
date:   2024-04-07 19:10:26 +0800
categories: golang
---
# 关键字
* 进程
> 进程是操作系统分配资源最小的单位
* 线程
> 线程是cpu调度的最小单位。调度时开销也比较大，占1M以上，cpu耗时1us左右。
* 协程
> 协程是用户态的线程。cpu消耗0.2us。
* 分段栈
> ???

# 简介
Go语言调度器使用与CPU数量相同的线程避免频繁切换线程导致的内存开销。在每一个线程上执行额外开销更低的Goroutine来降低操作系统和硬件的负载。

# 发展历史
1. 单线程调度器
> 程序只有一个线程，由G-M模型组成。优点:简单;缺点:无法利用多核加快任务处理。
2. 多线程调度器
> 允许多个线程同时运行。优点:利用了多cpu能力。缺点:全局锁和全局状态，竞争让性能下降。线程见的G传递导致开销增大。
3. 任务窃取调度器
```c
struct P
{
    Lock;
    G *gfree; // freelist, moved from sched
    G *ghead; // runnable, moved from sched
    G *gtail;
    MCache *mcache; // moved from M
    FixAlloc *stackalloc; // moved from M
    uint64 ncgocall;
    GCStats gcstats;
    // etc
    ...
};
```
>增加了处理器P,作为M-G的中间层。将一些全局状态和变量下发到P中。(缩小了需要竞争的全局资源)

>M-系统线程

>P-执行go代码所需要的资源,GOMAXPROCS指定p的数量,所有的p通过数组组织。

>M只有与P关联才能执行P中的G(pop P),执行完G后将P push到数组中。当M闲置或者处于系统调用时会与P断开。

>调度: P具有可执行goroutine列队,执行G时，需要从P的runnable列队pop一个G。如果当前P没有可执行G,会从任意一个P中偷取一半可执行的G.

>M阻塞:必须有其他M来处理G。有两种办法:1. 解除阻塞;2. 自旋。
自旋会燃烧CPU周期。
自旋有两方面

>闲置的M和P关联后自旋来寻找新的G

>没有关联P的M会自旋等来新的P。

4. 抢占式调度器



# 参考资料
[Scalable Go Scheduler Design Doc
](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit?pli=1#heading=h.mmq8lm48qfcw)